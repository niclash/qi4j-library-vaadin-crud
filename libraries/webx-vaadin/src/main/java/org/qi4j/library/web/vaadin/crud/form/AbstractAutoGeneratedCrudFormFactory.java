/*
 * Copyright 2007-2024, Niclas Hedhman, Sweden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.qi4j.library.web.vaadin.crud.form;

import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.Component;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.Focusable;
import com.vaadin.flow.component.HasLabel;
import com.vaadin.flow.component.HasSize;
import com.vaadin.flow.component.HasValue;
import com.vaadin.flow.component.HasValueAndElement;
import com.vaadin.flow.component.Key;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.PasswordField;
import com.vaadin.flow.component.textfield.TextArea;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.data.binder.Binder;
import com.vaadin.flow.data.converter.LocalDateToDateConverter;
import com.vaadin.flow.data.converter.StringToBigDecimalConverter;
import com.vaadin.flow.data.converter.StringToBigIntegerConverter;
import com.vaadin.flow.data.converter.StringToDoubleConverter;
import com.vaadin.flow.data.converter.StringToFloatConverter;
import com.vaadin.flow.data.converter.StringToIntegerConverter;
import com.vaadin.flow.data.converter.StringToLongConverter;
import com.vaadin.flow.function.SerializableSupplier;
import com.vaadin.flow.shared.util.SharedUtil;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;
import org.apache.polygene.api.association.AssociationDescriptor;
import org.apache.polygene.api.association.AssociationStateDescriptor;
import org.apache.polygene.api.composite.StateDescriptor;
import org.apache.polygene.api.composite.StatefulAssociationCompositeDescriptor;
import org.apache.polygene.api.entity.EntityComposite;
import org.apache.polygene.api.identity.IdentityGenerator;
import org.apache.polygene.api.injection.scope.Service;
import org.apache.polygene.api.injection.scope.Structure;
import org.apache.polygene.api.property.PropertyDescriptor;
import org.apache.polygene.api.structure.Module;
import org.apache.polygene.api.structure.TypeLookup;
import org.apache.polygene.api.unitofwork.UnitOfWork;
import org.apache.polygene.api.unitofwork.UnitOfWorkFactory;
import org.apache.polygene.spi.PolygeneSPI;
import org.qi4j.library.web.RenderAsValue;
import org.qi4j.library.web.vaadin.crud.CrudOperation;
import org.qi4j.library.web.vaadin.crud.CrudOperationException;
import org.qi4j.library.web.vaadin.data.converter.StringToByteConverter;
import org.qi4j.library.web.vaadin.data.converter.StringToCharacterConverter;

@SuppressWarnings("unchecked")
public abstract class AbstractAutoGeneratedCrudFormFactory<T> extends AbstractCrudFormFactory<T>
{
    @Structure
    UnitOfWorkFactory uowf;

    @Structure
    PolygeneSPI spi;

    @Service
    IdentityGenerator identityGenerator;

    @Service
    CrudFormConfiguration config;

    final TypeLookup typeLookup;

    protected Map<CrudOperation, String> buttonCaptions = new HashMap<>();
    protected Map<CrudOperation, Icon> buttonIcons = new HashMap<>();
    protected Map<CrudOperation, Set<String>> buttonStyleNames = new HashMap<>();
    protected Map<CrudOperation, String> buttonThemes = new HashMap<>();

    protected String cancelButtonCaption = "Cancel";
    protected String validationErrorMessage = "Please fix the errors and try again";
    protected Class<T> domainType;
    protected SerializableSupplier<T> newInstanceSupplier;

    protected Binder<T> binder;

    public AbstractAutoGeneratedCrudFormFactory(Class<T> domainType, Module module)
    {
        this.domainType = domainType;
        typeLookup = module.typeLookup();

        setButtonCaption(CrudOperation.READ, "Ok");
        setButtonCaption(CrudOperation.ADD, "Add");
        setButtonCaption(CrudOperation.UPDATE, "Update");
        setButtonCaption(CrudOperation.DELETE, "Yes, delete");

        setButtonIcon(CrudOperation.READ, null);
        setButtonIcon(CrudOperation.ADD, VaadinIcon.CHECK.create());
        setButtonIcon(CrudOperation.UPDATE, VaadinIcon.CHECK.create());
        setButtonIcon(CrudOperation.DELETE, VaadinIcon.TRASH.create());

        addButtonStyleName(CrudOperation.READ, null);
        addButtonTheme(CrudOperation.ADD, "primary");
        addButtonTheme(CrudOperation.UPDATE, "primary");
        addButtonTheme(CrudOperation.DELETE, "error");

        discoverProperties().forEach(pd -> showProperty(pd));
    }

    @Override
    public SerializableSupplier<T> getNewInstanceSupplier()
    {
        if (newInstanceSupplier == null)
        {
            newInstanceSupplier = () -> {
                UnitOfWork uow = uowf.currentUnitOfWork();
                return uow.newEntity(domainType, identityGenerator.generate(domainType));
            };
        }
        return newInstanceSupplier;
    }

    public void setButtonCaption(CrudOperation operation, String caption)
    {
        buttonCaptions.put(operation, caption);
    }

    public void setButtonIcon(CrudOperation operation, Icon icon)
    {
        buttonIcons.put(operation, icon);
    }

    public void addButtonStyleName(CrudOperation operation, String styleName)
    {
        buttonStyleNames.putIfAbsent(operation, new HashSet<>());
        buttonStyleNames.get(operation).add(styleName);
    }

    public void addButtonTheme(CrudOperation operation, String theme)
    {
        buttonThemes.put(operation, theme);
    }

    public void setCancelButtonCaption(String cancelButtonCaption)
    {
        this.cancelButtonCaption = cancelButtonCaption;
    }

    public void setValidationErrorMessage(String validationErrorMessage)
    {
        this.validationErrorMessage = validationErrorMessage;
    }

    @Override
    public Stream<? extends PropertyDescriptor> discoverProperties()
    {
        return typeLookup.allEntities()
            .map(StatefulAssociationCompositeDescriptor::state)
            .flatMap(StateDescriptor::properties);
    }

    @Override
    public Stream<? extends AssociationDescriptor> discoverAssociations()
    {
        return typeLookup.allEntities()
            .map(StatefulAssociationCompositeDescriptor::state)
            .flatMap(AssociationStateDescriptor::associations);

    }

    @Override
    public Stream<? extends AssociationDescriptor> discoverManyAssociations()
    {
        return typeLookup.allEntities()
            .map(StatefulAssociationCompositeDescriptor::state)
            .flatMap(AssociationStateDescriptor::manyAssociations);
    }

    @Override
    public Stream<? extends AssociationDescriptor> discoverNamedAssociations()
    {
        return typeLookup.allEntities().map(StatefulAssociationCompositeDescriptor::state).flatMap(AssociationStateDescriptor::namedAssociations);
    }

    protected List<HasValueAndElement> buildFields(CrudOperation operation,
                                                   T domainObject,
                                                   boolean readOnly)
    {
        binder = buildBinder(operation, domainObject);
        ArrayList<HasValueAndElement> fields = new ArrayList<>();

        boolean[] focused = new boolean[1];

        ArrayList<HasValueAndElement<? extends HasValue.ValueChangeEvent<T>, T>> fieldsWithCreationListeners = new ArrayList<>();
        ArrayList<FieldCreationListener> creationListeners = new ArrayList<>();
        discoverProperties().forEach( property ->
        {
            try
            {
                String fieldCaption = nameOf(property);
                Class<?> propertyType = property.valueType().primaryType();
                if (propertyType != null)
                {
                    HasValueAndElement<? extends HasValue.ValueChangeEvent<T>, T> field = buildField(property, domainObject);
                    if (field != null)
                    {
                        configureField(field, property, fieldCaption, readOnly);
                        bindField(field, property, propertyType);
                        fields.add(field);
                        if (!focused[0])
                        {
                            if (field.isEnabled() && !field.isReadOnly() && field instanceof Focusable)
                            {
                                ((Focusable) field).focus();
                                focused[0] = true;
                            }
                        }

                        FieldCreationListener creationListener = getFieldCreationListeners().get(property);
                        if (creationListener != null)
                        {
                            fieldsWithCreationListeners.add(field);
                            creationListeners.add(creationListener);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                throw new RuntimeException(
                    "Error creating Field for property " + domainObject.getClass().getName() + "." + property, e);
            }
        });

        binder.readBean(domainObject);

        for (int i = 0; i < fieldsWithCreationListeners.size(); i++)
        {
            creationListeners.get(i).fieldCreated(fieldsWithCreationListeners.get(i));
        }

        if (!fields.isEmpty() && !readOnly)
        {
            HasValueAndElement<? extends HasValue.ValueChangeEvent<T>, T> field = fields.get(0);
            if (field instanceof Focusable)
            {
                ((Focusable) field).focus();
            }
        }

        return fields;
    }

    protected <F> HasValueAndElement buildField( PropertyDescriptor property, T domainObject)
    {
        FieldProvider<? extends HasValue.ValueChangeEvent<T>, T> provider =
            (FieldProvider<? extends HasValue.ValueChangeEvent<T>, T>) getFieldProviders().get(property);
        return provider.buildField(domainObject);
    }

    private void configureField(HasValueAndElement<? extends HasValue.ValueChangeEvent<T>, T> field, PropertyDescriptor property, String fieldCaption, boolean readOnly)
    {
        if (fieldCaption == null)
        {
            fieldCaption = propertyIdToHumanFriendly(property);
        }
        if( field instanceof HasLabel labelField)
        {
            labelField.setLabel(fieldCaption);
        }
        if (field instanceof HasSize sizeField)
        {
            sizeField.setWidth("100%");
        }
        field.setReadOnly(readOnly);
        // TODO
//        if (!configuration.getDisabledProperties().isEmpty() && field instanceof HasEnabled)
//        {
//            field.setEnabled(!configuration.getDisabledProperties().contains(property));
//        }
    }

    protected String propertyIdToHumanFriendly(PropertyDescriptor property)
    {
        return SharedUtil.propertyIdToHumanFriendly(property);
    }

    protected void bindField(HasValueAndElement<? extends HasValue.ValueChangeEvent<T>, T> field, PropertyDescriptor property, Class<?> propertyType)
    {
        Binder.BindingBuilder bindingBuilder = binder.forField(field);
        if (TextField.class.isAssignableFrom(field.getClass()) || PasswordField.class.isAssignableFrom(field.getClass())
            || TextArea.class.isAssignableFrom(field.getClass()))
        {
            bindingBuilder = bindingBuilder.withNullRepresentation("");
        }

        if (getConverters().containsKey(property))
        {
            bindingBuilder = bindingBuilder.withConverter(getConverters().get(property));

        }
        else if (Double.class.isAssignableFrom(propertyType) || double.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToDoubleConverter(null, "Must be a number"));

        }
        else if (Long.class.isAssignableFrom(propertyType) || long.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToLongConverter(null, "Must be a number"));

        }
        else if (BigDecimal.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToBigDecimalConverter(null, "Must be a number"));

        }
        else if (BigInteger.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToBigIntegerConverter(null, "Must be a number"));

        }
        else if (Integer.class.isAssignableFrom(propertyType) || int.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToIntegerConverter(null, "Must be a number"));

        }
        else if (Byte.class.isAssignableFrom(propertyType) || byte.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToByteConverter(null, "Must be a number"));

        }
        else if (Character.class.isAssignableFrom(propertyType) || char.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToCharacterConverter());

        }
        else if (Float.class.isAssignableFrom(propertyType) || float.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new StringToFloatConverter(null, "Must be a number"));

        }
        else if (Date.class.isAssignableFrom(propertyType))
        {
            bindingBuilder = bindingBuilder.withConverter(new LocalDateToDateConverter());
        }

        bindingBuilder.bind(
            entity -> spi.entityStateOf((EntityComposite) entity).propertyValueOf(property.qualifiedName()),
            (entity, value) -> spi.entityStateOf((EntityComposite) entity).setPropertyValue(property.qualifiedName(), value)
        );
    }

    protected Binder<T> buildBinder(CrudOperation operation, T domainObject)
    {
        return (Binder<T>) new Binder<>(domainObject.getClass());
    }

    protected Button buildOperationButton(CrudOperation operation, T domainObject,
                                          ComponentEventListener<ClickEvent<Button>> clickListener)
    {
        if (clickListener == null)
        {
            return null;
        }

        String caption = buttonCaptions.get(operation);
        Icon icon = buttonIcons.get(operation);
        Button button = icon != null ? new Button(caption, icon) : new Button(caption);
        if (buttonStyleNames.containsKey(operation))
        {
            buttonStyleNames.get(operation).stream().filter(Objects::nonNull)
                .forEach(button::addClassName);
        }
        if (buttonThemes.containsKey(operation))
        {
            button.getElement().setAttribute("theme", buttonThemes.get(operation));
        }

        button.addClickListener(event -> {
            if (binder.writeBeanIfValid(domainObject))
            {
                try
                {
                    clickListener.onComponentEvent(event);
                }
                catch (Exception e)
                {
                    showError(operation, e);
                }
            }
            else
            {
                showNotification(validationErrorMessage);
            }
        });
        return button;
    }

    @Override
    public void showError(CrudOperation operation, Exception e)
    {
        if (errorListener != null)
        {
            errorListener.accept(e);
        }
        else
        {
            if (CrudOperationException.class.isAssignableFrom(e.getClass()))
            {
                showNotification(e.getMessage());
            }
            else
            {
                showNotification("Error");
                throw new RuntimeException("Error executing " + operation.name() + " operation", e);
            }
        }
    }

    protected Button buildCancelButton(ComponentEventListener<ClickEvent<Button>> clickListener)
    {
        if (clickListener == null)
        {
            return null;
        }

        return new Button(cancelButtonCaption, clickListener);
    }

    protected Component buildFooter(CrudOperation operation, T domainObject,
                                    ComponentEventListener<ClickEvent<Button>> cancelButtonClickListener,
                                    ComponentEventListener<ClickEvent<Button>> operationButtonClickListener)
    {
        Button operationButton = buildOperationButton(operation, domainObject, operationButtonClickListener);
        Button cancelButton = buildCancelButton(cancelButtonClickListener);

        HorizontalLayout footerLayout = new HorizontalLayout();
        footerLayout.setSizeUndefined();
        footerLayout.setSpacing(true);
        footerLayout.setPadding(false);

        if (operationButton != null)
        {
            operationButton.addClickShortcut(Key.ENTER);
            footerLayout.add(operationButton);
        }

        if (cancelButton != null)
        {
            footerLayout.add(cancelButton);
        }
        return footerLayout;
    }

    public String nameOf(PropertyDescriptor property)
    {
        RenderAsValue renderAsValue = property.metaInfo(RenderAsValue.class);
        if (renderAsValue != null)
            return renderAsValue.title();
        return humanize(property.qualifiedName().name());
    }

    static String humanize(String name)
    {
        int nameLength = name.length();
        StringBuilder humanName = new StringBuilder(nameLength);
        for (int i = 0; i < nameLength; i++)
        {
            char ch = name.charAt(i);
            if (Character.isUpperCase(ch))
            {
                humanName.append(" ");
            }
            if (i == 0)
            {
                ch = Character.toUpperCase(ch);
            }
            humanName.append(ch);
        }
        return humanName.toString();
    }
}
